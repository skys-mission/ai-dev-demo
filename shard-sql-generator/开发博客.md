# 分片SQL生成器开发博客

## 1. 项目启动

### 1.1 需求分析

#### 核心需求
开发一个用于生成数据库分片SQL的工具平台，主要功能包括：
- 支持多种预制的DB分片hash规则算法（需支持参数传递）
- 允许用户自定义和管理分片规则脚本
- 提供直观易用的界面来配置分片参数和生成分片SQL
- 支持批量处理和结果导出功能

#### 技术约束
- 后端必须使用纯Node.js原生实现，不允许使用任何第三方依赖
- 前端同样采用原生技术栈（HTML5 + CSS3 + JavaScript）
- 同时提供裸机部署和Docker容器部署方案

#### 界面要求
- 高级感和简洁感并存
- 良好的易用性和直观的操作流程
- 自然舒服的色彩过渡效果
- 响应式设计，支持不同屏幕尺寸

### 1.2 技术选型

- **后端**：Node.js 原生 (无第三方依赖) - 确保轻量、安全、部署简单
- **前端**：HTML5 + CSS3 + JavaScript (原生) - 确保界面性能和兼容性
- **存储**：
  - 前端：localStorage - 用于保存用户自定义脚本和操作历史
  - 后端：JSON文件存储 - 用于配置和基础数据
- **部署**：
  - 裸机部署：直接运行Node.js应用
  - Docker容器：提供标准化的部署环境

## 2. 项目规划

### 2.1 架构设计

```
┌─────────────────────────────────────────────────────────────────────┐
│                          前端应用 (SPA)                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │ SQL输入模块 │  │ 算法配置模块│  │ 结果展示模块│  │ 脚本管理模块│  │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  │
│         │                │                │                │         │
│         └────────────────┼────────────────┼────────────────┘         │
│                          ▼                                           │
│                  ┌─────────────┐                                     │
│                  │ 历史记录模块│                                     │
│                  └─────────────┘                                     │
└────────────────────────┬─────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          后端服务                                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │ 路由处理模块│  │ SQL生成模块 │  │ 脚本执行模块│  │ 配置管理模块│  │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  │
│         │                │                │                │         │
│         └────────────────┼────────────────┼────────────────┘         │
│                          ▼                                           │
│                  ┌─────────────┐                                     │
│                  │ 安全执行环境│                                     │
│                  └─────────────┘                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心功能模块

1. **SQL生成器**：解析输入SQL并根据分片规则转换为分片SQL
2. **分片算法库**：内置多种分片算法，支持参数配置
3. **脚本管理器**：管理内置和自定义分片脚本
4. **用户界面**：提供直观的操作界面
5. **API服务**：提供RESTful接口供前端调用

## 3. 详细设计

### 3.1 分片算法设计

#### 内置算法列表

| 算法类型 | 适用场景 | 参数说明 |
|---------|---------|---------|
| 取模算法 | 数据均匀分布场景 | `mod`：取模基数 |
| 范围分片 | 有明确范围划分的场景 | `rangeRules`：范围规则配置 |
| 哈希分片 | 字符串类型分片键 | `hashAlgorithm`：哈希算法<br>`numShards`：分片数量 |
| 一致性哈希 | 动态增减分片场景 | `nodes`：节点配置<br>`virtualNodes`：虚拟节点数 |
| 日期分片 | 时间序列数据 | `dateFormat`：日期格式 |
| 自定义脚本 | 特殊需求场景 | `script`：自定义脚本内容 |

#### 算法实现示例（取模算法）

```javascript
// core/sql-generator.js
sshardAlgorithms.mod = (value, config) => {
  const modValue = config.mod || 10;
  const numValue = Number(value);
  if (isNaN(numValue)) {
    // 对字符串进行哈希转换
    let hash = 0;
    for (let i = 0; i < value.length; i++) {
      hash = (hash << 5) - hash + value.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash) % modValue;
  }
  return numValue % modValue;
};
```

### 3.2 API接口设计

| 接口路径 | 方法 | 功能描述 | 请求体 | 响应体 |
|---------|------|---------|--------|--------|
| `/api/generate` | POST | 生成分片SQL | `{ sql, shardKey, shardKeyValues, shardAlgorithm, algorithmParams, customScript }` | `{ shardSQL, aggregateSQL }` |
| `/api/calculate-shard` | POST | 计算分片ID | `{ value, algorithm, config }` | `{ shardId }` |
| `/api/generate-sql` | POST | 生成分片SQL（旧版） | `{ sql, shardKey, shardValue, shardId }` | `{ success, result }` |
| `/api/batch-generate` | POST | 批量生成分片SQL | `{ sql, shardKey, shardValues, algorithm, algorithmConfig }` | `{ success, results }` |

## 4. 实现过程

### 4.1 核心功能实现细节

#### SQL生成器实现

```javascript
// core/sql-generator.js
function generateShardSQL(sql, shardKey, shardValue, shardId) {
  // 验证输入参数
  if (!sql || !shardKey || shardValue === undefined || shardId === undefined) {
    throw new Error('缺少必要参数');
  }

  // 替换占位符
  let shardSQL = sql.replace(/\?/g, (match, offset) => {
    // 检查是否在引号内
    const beforeMatch = sql.substring(0, offset);
    const quoteCount = (beforeMatch.match(/'/g) || []).length;
    if (quoteCount % 2 !== 0) {
      return match; // 在引号内，不替换
    }
    return `'${shardValue}'`;
  });

  // 添加分片后缀
  const tableMatch = shardSQL.match(/FROM\s+([a-zA-Z_]+)/i);
  if (tableMatch) {
    const tableName = tableMatch[1];
    const shardTableName = `${tableName}_${shardId}`;
    shardSQL = shardSQL.replace(new RegExp(`FROM\s+${tableName}`, 'i'), `FROM ${shardTableName}`);
  }

  return shardSQL;
}
```

#### 自定义脚本安全执行

```javascript
// core/script-manager.js
function executeCustomScript(scriptContent, value, config) {
  // 验证脚本内容
  if (!validateCustomScript(scriptContent)) {
    throw new Error('脚本验证失败');
  }

  // 创建安全的执行环境
  const vm = require('vm');
  const sandbox = {
    value,
    config,
    console: {
      log: () => {}, // 禁用console输出
      error: () => {}
    },
    setTimeout: () => {}, // 禁用定时器
    setInterval: () => {}
  };

  // 执行脚本
  const context = vm.createContext(sandbox);
  vm.runInContext(scriptContent, context);

  // 执行getShardId函数
  if (typeof context.getShardId === 'function') {
    return context.getShardId(value, config);
  }\ else {
    throw new Error('脚本必须定义getShardId函数');
  }
}
```

### 4.2 前端界面实现

#### 核心界面布局

```html
<!-- public/index.html -->
<div class="app-container">
  <header class="header">
    <div class="container">
      <h1 class="app-title">分片SQL生成器</h1>
      <div class="header-actions">
        <button id="theme-toggle" class="btn-icon">
          <span class="icon">🌙</span>
        </button>
        <button id="help-btn" class="btn-icon">
          <span class="icon">❓</span>
        </button>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="container">
      <div class="left-panel">
        <!-- 算法选择和参数配置 -->
      </div>
      <div class="middle-panel">
        <!-- SQL输入和生成结果 -->
      </div>
      <div class="right-panel">
        <!-- 历史记录和脚本管理 -->
      </div>
    </div>
  </main>
</div>
```

### 4.3 脚本管理功能

#### 前端脚本管理实现

```javascript
// public/modules/script-manager.js
const ScriptManager = (() => {
  let scripts = [];

  const loadScripts = () => {
    // 从localStorage加载脚本
    scripts = JSON.parse(localStorage.getItem('shardScripts')) || [];
    updateScriptsList();
  };

  const saveScript = async (script) => {
    try {
      // 生成唯一ID
      const newScript = {
        ...script,
        id: Date.now().toString()
      };
      scripts.push(newScript);
      localStorage.setItem('shardScripts', JSON.stringify(scripts));
      updateScriptsList();
      return newScript;
    } catch (error) {
      console.error('保存脚本失败:', error);
      throw error;
    }
  };

  // 其他方法...

  return {
    loadScripts,
    saveScript,
    updateScript,
    deleteScript,
    getScriptById,
    getAllScripts
  };
})();
```

### 4.4 项目优化和清理

在项目完成后，我们进行了一次全面的优化和清理：

1. **移除无用的目录**：删除了不再使用的`data/scripts`目录，该目录原本用于存储自定义脚本，但实际已被前端localStorage替代

2. **清理冗余代码**：
   - 移除了`core/script-manager.js`中所有与文件系统操作相关的代码（约112行）
   - 删除了不必要的fs和path模块依赖
   - 简化了脚本管理逻辑，仅保留必要功能

3. **更新依赖关系**：
   - 更新了`core/sql-generator.js`，移除了对已弃用功能的依赖
   - 确保所有模块间的调用关系清晰合理

4. **删除过时测试文件**：
   - 删除了`test-script-manager.js`，该文件测试了已被移除的功能

### 4.5 测试和验证

我们创建了全面的测试套件来验证项目的功能：

```bash
# 核心功能测试
node test-core.js

# API接口测试
node test-api.js

# SQL生成测试
node test-enhanced-sql.js

# 综合测试
node test-final.js
```

所有测试均通过，确保了项目的稳定性和可靠性。

## 5. 技术亮点

### 5.1 纯Node.js原生实现

- **零依赖**：不使用任何第三方库，确保项目轻量（总代码量约2000行）
- **高安全性**：减少了依赖带来的安全风险
- **部署简单**：只需Node.js环境即可运行
- **性能优异**：原生实现确保了高效的运行性能

### 5.2 安全的自定义脚本执行

- 使用Node.js的VM模块创建安全的执行沙箱
- 限制脚本的执行权限，禁用危险操作
- 严格的脚本验证机制，确保脚本格式正确

### 5.3 现代化用户界面

- **响应式设计**：适配不同屏幕尺寸（桌面端和移动端）
- **主题切换**：支持浅色和深色主题
- **实时预览**：输入即所见的交互体验
- **SQL语法高亮**：提升代码可读性
- **历史记录**：快速回溯和复用之前的操作

### 5.4 灵活的分片算法支持

- 内置6种常用分片算法
- 支持自定义算法扩展
- 算法参数动态配置
- 算法切换无缝衔接

## 6. 部署方案

### 6.1 裸机部署

#### 系统要求
- Node.js 14.x 或更高版本
- 512MB 以上内存
- 100MB 以上磁盘空间

#### 部署步骤

1. **下载项目**
   ```bash
   git clone https://github.com/ai-dev-demo/shard-sql-generator.git
   cd shard-sql-generator
   ```

2. **启动服务**
   ```bash
   node server.js
   ```

3. **访问应用**
   打开浏览器访问：`http://localhost:3000`

### 6.2 Docker容器部署

#### 构建镜像

```bash
docker build -t shard-sql-generator .
```

#### 运行容器

```bash
docker run -d -p 3000:3000 --name shard-sql-generator shard-sql-generator
```

#### 使用Docker Compose

```bash
docker-compose up -d
```

## 7. 使用说明

### 7.1 基本使用流程

1. **输入SQL语句**：在左侧SQL输入框中输入原始SQL语句
2. **配置分片规则**：
   - 选择分片算法（如取模、哈希等）
   - 设置算法参数（如取模基数、哈希算法等）
   - 输入分片键和分片键值
3. **生成SQL**：点击"生成分片SQL"按钮
4. **查看结果**：在右侧结果区域查看生成的分片SQL
5. **复制或导出**：复制生成的SQL或导出结果

### 7.2 自定义脚本使用

1. **切换到脚本管理**：点击右侧面板的"脚本列表"标签
2. **添加新脚本**：点击"添加脚本"按钮
3. **编写脚本**：在弹出的编辑器中编写自定义分片算法
   ```javascript
   // 自定义分片算法示例
   function getShardId(value, config) {
     // 基于用户ID的自定义分片逻辑
     const userId = parseInt(value);
     const shardCount = config.shardCount || 8;
     return userId % shardCount;
   }
   ```
4. **保存脚本**：点击"保存"按钮
5. **使用脚本**：在分片算法选择中选择"自定义"，然后选择刚刚创建的脚本

## 8. 项目总结

### 8.1 实现的功能

- ✅ SQL生成：支持6种分片算法，可生成分片SQL
- ✅ 批量处理：支持批量生成分片SQL
- ✅ 脚本管理：内置算法 + 用户自定义脚本
- ✅ 用户界面：现代化设计，简洁易用
- ✅ API接口：完整的RESTful API服务
- ✅ 历史记录：保存用户操作历史
- ✅ 部署方案：裸机部署 + Docker容器部署
- ✅ 性能优化：核心功能优化和代码精简

### 8.2 遇到的问题和解决方案

1. **SQL解析复杂**：
   - 问题：SQL语句的解析和替换需要考虑各种复杂情况（如引号内的占位符）
   - 解决方案：采用正则表达式和字符串处理结合的方式，通过检查引号数量判断是否在引号内

2. **自定义脚本安全**：
   - 问题：用户自定义脚本可能包含恶意代码
   - 解决方案：使用Node.js的VM模块创建安全的执行环境，限制脚本权限

3. **前端交互流畅性**：
   - 问题：大量DOM操作可能导致界面卡顿
   - 解决方案：优化DOM操作，使用事件委托，减少不必要的重绘

4. **数据持久化**：
   - 问题：需要在不同设备间同步用户自定义脚本
   - 解决方案：使用前端localStorage存储，同时保留后端存储接口以便未来扩展

### 8.3 未来展望

- **更多算法支持**：添加更多类型的分片算法
- **SQL语法验证**：实现SQL语法检查和错误提示
- **多格式导出**：支持导出为SQL文件、Excel等格式
- **团队协作**：添加用户认证和团队共享功能
- **数据库支持**：支持更多数据库类型的SQL语法
- **性能监控**：添加性能监控和分析功能

## 9. 总结

分片SQL生成器是一个功能完整、设计精良的数据库工具，它解决了数据库分片场景下SQL生成的复杂问题。项目采用纯Node.js原生实现，确保了轻量、安全和高性能。界面设计现代化且易用，支持多种分片算法和自定义脚本，能够满足不同场景下的需求。

通过这个项目，我们展示了如何使用原生技术栈开发一个功能完整的Web应用，同时保持代码的简洁性和可维护性。项目的成功实现也验证了原生技术栈在现代Web开发中的可行性和优势。

---

**更新日志**：
- 2023-11-21：项目启动，完成需求分析和博客初始化
- 2023-11-22：完成前端界面开发
- 2023-11-23：实现核心功能模块
- 2023-11-24：开发API接口和数据库交互
- 2023-11-25：完成测试和优化
- 2023-11-26：实现部署配置和文档编写
- 2024-05-06：项目优化和清理，移除无用目录和冗余代码
- 2024-05-07：完善文档和使用说明，准备项目展示